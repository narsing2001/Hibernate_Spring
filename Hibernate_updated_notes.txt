
https://www.digitalocean.com/community/tutorials/hibernate-one-to-one-mapping-example-annotation#hibernate-one-to-one-mapping-annotation

https://www.digitalocean.com/community/tutorials/hibernate-one-to-many-mapping-annotation#one-to-many-mapping-in-hibernate

https://www.digitalocean.com/community/tutorials/hibernate-many-to-many-mapping-join-tables

===================================================================================================================================

In Hibernate and JPA, the mappedBy attribute is used in bidirectional relationships to indicate the inverse side of the association. It tells Hibernate that the mapping for this side of the relationship is already defined by the other entity, preventing the creation of redundant tables or foreign keys.
Here's a breakdown:
Bidirectional Relationships: When two entities have a relationship where each entity knows about the other (e.g., a User has many Posts, and each Post belongs to a User), it's a bidirectional relationship.
Owning vs. Inverse Side: In a bidirectional relationship, one side is designated as the owning side and the other as the inverse side. The owning side is responsible for managing the foreign key column in the database.
mappedBy's Role: The mappedBy attribute is placed on the inverse side of the relationship. Its value is the name of the field in the owning entity that refers back to the current (inverse) entity.

===================================================================================================================================

In Hibernate, the terms "unidirectional" and "bidirectional" refer to the direction in which an association between two entities can be navigated.

Unidirectional Association:
In a unidirectional association, the relationship is defined and navigable from only one of the two associated entities.
Only the "owning side" of the relationship is aware of and manages the association.
Updates to the relationship in the database are primarily handled by the owning side.
For example, in a One-to-Many unidirectional relationship, the "many" side (child entity) would have a reference to the "one" side (parent entity), but the parent entity would not have a collection of its child entities.

Bidirectional Association:
In a bidirectional association, the relationship is defined and navigable from both associated entities.
Both entities are aware of and can access the other entity in the relationship.
A bidirectional relationship has an "owning side" and an "inverse side." The owning side is responsible for managing the relationship in the database, while the inverse side uses the mappedBy attribute to indicate that it is the inverse of the relationship defined on the owning side. 
For example, in a One-to-Many bidirectional relationship, the "many" side would have a reference to the "one" side, and the "one" side would have a collection of its "many" side entities.

Key Differences:
Navigation: Unidirectional allows navigation in one direction, while bidirectional allows navigation in both directions.
Ownership: Unidirectional has only an owning side. Bidirectional has an owning side and an inverse side, where the owning side controls the relationship in the database.
Complexity: Unidirectional associations are generally simpler to implement and manage. Bidirectional associations require more careful handling to ensure consistency, especially when updating the relationship from both sides.
Performance: Unidirectional associations can sometimes offer better performance in specific scenarios as they might avoid loading unnecessary data. Bidirectional associations can potentially lead to performance issues if not managed correctly, particularly with lazy loading and serialization.

===================================================================================================================================

Cascading in Hibernate refers to the propagation of state transitions from a parent entity to its associated child entities. This means that when you perform an operation (like saving, updating, or deleting) on a parent entity, the same operation can automatically be applied to its related entities without requiring explicit code for each child.

Why use Cascading?
Simplifies code: Reduces the need to manually manage the lifecycle of related entities.
Ensures data consistency: Helps maintain the integrity of relationships by automatically applying changes across connected entities.
Avoids "transient instance" exceptions: Prevents errors that occur when attempting to save a parent entity without also saving its associated child entities.

How to configure Cascading:
Cascading is configured in the entity mapping using the cascade attribute within relationship annotations (e.g., @OneToMany, @OneToOne, @ManyToMany). You specify the desired CascadeType to control which operations should be cascaded.
Common CascadeType options:
CascadeType.ALL: Cascades all state transitions (PERSIST, MERGE, REMOVE, REFRESH, DETACH).
CascadeType.PERSIST: Cascades the persist (create/save) operation.
CascadeType.MERGE: Cascades the merge (update) operation.
CascadeType.REMOVE: Cascades the remove (delete) operation.
CascadeType.REFRESH: Cascades the refresh operation (reloading entity state from the database).
CascadeType.DETACH: Cascades the detach operation (detaching entities from the persistence context).

===================================================================================================================================

The N+1 query problem in Hibernate, and other ORM frameworks, is a common performance issue that arises when an application executes numerous database queries to retrieve related entities.
Explanation:
Initial Query (the "1"): An initial query is performed to fetch a collection of parent entities. For example, retrieving all Department entities.
Subsequent Queries (the "N"): If the associated child entities (e.g., Employee entities for each Department) are configured for lazy loading and are then accessed within a loop or iteration, Hibernate will execute a separate query for each parent entity to fetch its associated children. This results in "N" additional queries, where N is the number of parent entities retrieved in the initial query. 
Example:
Consider a Department entity with a @OneToMany relationship to an Employee entity, where the Employee collection is lazily loaded.
Java

// Fetch all departments
List<Department> departments = departmentRepository.findAll();

// Iterate through departments and access employees
for (Department department : departments) {
    // This line triggers an additional query for each department to fetch its employees
    System.out.println(department.getEmployees().size()); 
}
In this scenario, one query fetches all departments, and then N additional queries are executed to fetch the employees for each department, leading to a total of N+1 queries.

Impact:
Performance Degradation: The large number of database round trips significantly slows down application performance, especially with a large number of parent entities.
Increased Database Load: The database server experiences higher load due to the numerous individual queries.
Scalability Issues: The N+1 problem can hinder the scalability of the application.

Solutions:
Hibernate provides several ways to address the N+1 problem:

JOIN FETCH: Explicitly fetch associated entities in a single query using JOIN FETCH in JPQL or HQL.
Java

    SELECT d FROM Department d LEFT JOIN FETCH d.employees
	
@BatchSize: Configure batch fetching for collections or associations, allowing Hibernate to fetch a batch of associated entities in a single query instead of one by one.

===================================================================================================================================
In Hibernate, the default fetch type for associations depends on the cardinality of the relationship:

To-one associations (e.g., @ManyToOne, @OneToOne): The default fetch type is FetchType.EAGER. This means that when the parent entity is loaded, the associated entity will also be loaded immediately.

To-many associations (e.g., @OneToMany, @ManyToMany): The default fetch type is FetchType.LAZY. This means that the associated collection of entities will not be loaded until it is explicitly accessed (e.g., by calling a getter method on the collection).

These defaults are part of the JPA specification and are generally followed by Hibernate. You can override these defaults by explicitly setting the fetch attribute within the association annotation (e.g., @OneToMany(fetch = FetchType.EAGER)).


===================================================================================================================================

In Hibernate, the FetchType determines how associated entities or collections are loaded from the database when a parent entity is retrieved. There are two primary fetch types:
FetchType.LAZY:
This is the default fetch type for collections (e.g., @OneToMany, @ManyToMany) and is the recommended approach for most associations.
Associated entities or collections are not loaded immediately when the parent entity is fetched. Instead, a proxy object is created.
The actual data for the associated entity or collection is only retrieved from the database when it is explicitly accessed in your code (e.g., by calling a getter method on the associated object or iterating over a collection).
Benefit: Improves initial load times and reduces the amount of data transferred, especially when the associated data is not always needed.
Drawback: Can lead to the "N+1 select problem" if you access a lazy association within a loop, as a separate query might be executed for each access. This can be mitigated using techniques like join fetch or batch fetching.
FetchType.EAGER:
This is the default fetch type for single-valued associations (e.g., @OneToOne, @ManyToOne).
Associated entities are loaded immediately along with the parent entity in a single database query, often using a JOIN.
Benefit: Avoids the "N+1 select problem" for the eagerly fetched association and ensures all related data is available upfront.
Drawback: Can lead to fetching unnecessary data if the associated entity is not always used, potentially increasing memory consumption and query complexity, especially with multiple eager associations or large collections.
How to specify FetchType:
You can specify the fetch type using the fetch attribute within the mapping annotations for associations, such as @OneToOne, @OneToMany, @ManyToOne, and @ManyToMany.
Example:
Java

@Entity
public class Post {
    @Id
    private Long id;

    @OneToMany(mappedBy = "post", fetch = FetchType.LAZY) // Lazy fetching for comments
    private Set<Comment> comments = new HashSet<>();

    // ... other fields and methods
}

@Entity
public class Comment {
    @Id
    private Long id;

    @ManyToOne(fetch = FetchType.EAGER) // Eager fetching for the associated Post
    @JoinColumn(name = "post_id")
    private Post post;

    // ... other fields and methods
}
Choosing the right FetchType:
Prioritize FetchType.LAZY: for most associations to optimize performance and resource usage.
Use FetchType.EAGER sparingly: and only when you are certain that the associated data will always be required immediately when the parent entity is loaded.
Consider using join fetch in JPQL or Criteria API queries to eagerly load specific lazy associations when needed for a particular use case, avoiding the N+1 problem without making the association eagerly fetched by default.


===================================================================================================================================

Here is an example demonstrating the use of Hibernate Validator for bean validation in a Java application.
1. Add Dependencies (Maven Example):
Code

<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>8.0.1.Final</version> <!-- Use the latest stable version -->
</dependency>
<dependency>
    <groupId>org.glassfish</groupId>
    <artifactId>jakarta.el</artifactId>
    <version>4.0.2</version> <!-- Required for expression language support -->
</dependency>
2. Create a Validated Bean:
Java

import jakarta.validation.constraints.Email;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;

public class User {

    @NotBlank(message = "Name cannot be blank")
    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    private String name;

    @NotBlank(message = "Email cannot be blank")
    @Email(message = "Invalid email format")
    private String email;

    @Min(value = 18, message = "Age must be at least 18")
    private int age;

    // Getters and Setters
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmail() { return email; }
    public void setEmail(String email) { this.email = email; }
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
}
3. Perform Validation:
Java

import jakarta.validation.ConstraintViolation;
import jakarta.validation.Validation;
import jakarta.validation.Validator;
import jakarta.validation.ValidatorFactory;
import java.util.Set;

public class ValidationExample {

    public static void main(String[] args) {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        Validator validator = factory.getValidator();

        User validUser = new User();
        validUser.setName("John Doe");
        validUser.setEmail("john.doe@example.com");
        validUser.setAge(30);

        User invalidUser = new User();
        invalidUser.setName(""); // Blank name
        invalidUser.setEmail("invalid-email"); // Invalid email format
        invalidUser.setAge(16); // Age below 18

        System.out.println("Validating validUser:");
        Set<ConstraintViolation<User>> violations1 = validator.validate(validUser);
        if (violations1.isEmpty()) {
            System.out.println("User is valid.");
        } else {
            for (ConstraintViolation<User> violation : violations1) {
                System.out.println(violation.getPropertyPath() + ": " + violation.getMessage());
            }
        }

        System.out.println("\nValidating invalidUser:");
        Set<ConstraintViolation<User>> violations2 = validator.validate(invalidUser);
        if (violations2.isEmpty()) {
            System.out.println("User is valid.");
        } else {
            for (ConstraintViolation<User> violation : violations2) {
                System.out.println(violation.getPropertyPath() + ": " + violation.getMessage());
            }
        }

        factory.close();
    }
}
This example demonstrates how to define validation rules using annotations on a Java bean and then use the Validator API to check for violations. The ConstraintViolation objects provide details about any failed validations.

https://howtodoinjava.com/hibernate/hibernate-validator-java-bean-validation/
https://medium.com/@AlexanderObregon/handling-validation-in-spring-boot-with-bean-validation-hibernate-validator-6d1b2fc06cd2



===================================================================================================================================



===================================================================================================================================


Sanitizing the request body in Spring Boot before it reaches the controller is a crucial security measure to prevent various attacks like Cross-Site Scripting (XSS) and SQL Injection. This can be achieved through several mechanisms:
1. Using Filters:
Filters are a powerful way to intercept requests and responses in a Spring Boot application. You can create a custom Filter that reads the request body, sanitizes its content, and then wraps the original request with a modified one containing the sanitized body.
Java

import jakarta.servlet.*;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletRequestWrapper;
import java.io.BufferedReader;
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.StandardCharsets;
import java.util.stream.Collectors;

public class SanitizingFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
            throws IOException, ServletException {
        HttpServletRequest httpServletRequest = (HttpServletRequest) request;
        String requestBody = httpServletRequest.getReader().lines().collect(Collectors.joining(System.lineSeparator()));

        // Perform sanitization on requestBody here
        String sanitizedBody = sanitize(requestBody); 

        // Create a new request wrapper with the sanitized body
        HttpServletRequestWrapper wrappedRequest = new HttpServletRequestWrapper(httpServletRequest) {
            @Override
            public ServletInputStream getInputStream() throws IOException {
                final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(sanitizedBody.getBytes(StandardCharsets.UTF_8));
                return new ServletInputStream() {
                    @Override
                    public boolean isFinished() {
                        return byteArrayInputStream.available() == 0;
                    }

                    @Override
                    public boolean isReady() {
                        return true;
                    }

                    @Override
                    public void setReadListener(ReadListener listener) {
                        // Not implemented for simplicity
                    }

                    @Override
                    public int read() throws IOException {
                        return byteArrayInputStream.read();
                    }
                };
            }

            @Override
            public BufferedReader getReader() throws IOException {
                return new BufferedReader(new InputStreamReader(this.getInputStream(), StandardCharsets.UTF_8));
            }
        };

        chain.doFilter(wrappedRequest, response);
    }

    private String sanitize(String input) {
        // Implement your sanitization logic here.
        // For example, using OWASP ESAPI or a custom regex-based approach
        // to remove or encode potentially malicious characters.
        return input.replaceAll("<script>", "").replaceAll("</script>", ""); // Simple example, use a robust library
    }
}
2. Using Interceptors:
Spring Interceptors provide a way to intercept requests before they reach the controller and after the controller has processed them. While they can modify the request, directly modifying the request body within an interceptor can be more complex than using a Filter due to the nature of request body streams.
3. Custom HttpMessageConverter:
For specific content types (e.g., JSON), you can implement a custom HttpMessageConverter to deserialize the request body into a Java object and perform sanitization during the deserialization process. This approach is more targeted to data types.
4. Input Validation and Sanitization Libraries:
Leverage libraries specifically designed for input validation and sanitization, such as OWASP ESAPI or Hibernate Validator. You can integrate these libraries into your application and apply their sanitization functions to the received data within your controllers or service layers after the request body has been bound to a Java object.
Choosing the right approach depends on your specific needs:
Filters offer a broad, application-wide approach to intercept and modify the request body before it reaches any controller.
Custom HttpMessageConverter is suitable for specific data types and offers control during deserialization.
Validation and Sanitization Libraries provide robust, pre-built solutions for common sanitization needs and can be integrated at various points in your application.


===================================================================================================================================

https://blog.tericcabrel.com/validate-request-body-and-parameter-in-spring-boot/

https://medium.com/@tericcabrel/write-custom-validator-for-request-body-in-spring-boot-31a6aa5e53b1

https://github.com/tericcabrel/blog-tutorials/blob/main/springboot-tailwind-css/src/main/resources/templates/home.html

https://blog.tericcabrel.com/validate-request-body-and-parameter-in-spring-boot/


=========================================================================================================================================


